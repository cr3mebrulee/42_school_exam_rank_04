One process can (if it has suitable permissions) send a signal to another process.
In this use, signals can be employed as a synchronization technique, or even as a
primitive form of interprocess communication (IPC). It is also possible for a pro-
cess to send a signal to itself. However, the usual source of many signals sent to a
process is the kernel. Among the types of events that cause the kernel to generate a
signal for a process are the following:

1. A hardware exception occurred, meaning that the hardware detected a fault
condition that was notified to the kernel, which in turn sent a corresponding
signal to the process concerned. Examples of hardware exceptions include
executing a malformed machine-language instruction, dividing by 0, or refer-
encing a part of memory that is inaccessible.
2. The user typed one of the terminal special characters that generate signals.
These characters include the interrupt character (usually Control-C) and the
suspend character (usually Control-Z).
3. A software event occurred. For example, input became available on a file
descriptor, the terminal window was resized, a timer went off, the process’s
CPU time limit was exceeded, or a child of this process terminated.

Each signal is defined as a unique (small) integer, starting sequentially from 1.
These integers are defined in <signal.h> with symbolic names of the form SIGxxxx.
Since the actual numbers used for each signal vary across implementations, it is
these symbolic names that are always used in programs.

Signals fall into two broad categories. The first set constitutes the traditional or
standard signals (Linux signal(7) manual page), which are used by the kernel to notify processes of events. On
Linux, the standard signals are numbered from 1 to 31. The other set of signals consists 
of the realtime signals.

A signal is said to be generated by some event. Once generated, a signal is later
delivered to a process, which then takes some action in response to the signal.
Between the time it is generated and the time it is delivered, a signal is said to be
pending.

Normally, a pending signal is delivered to a process as soon as it is next sched-
uled to run, or immediately if the process is already running (e.g., if the process
sent a signal to itself). Sometimes, however, we need to ensure that a segment of
code is not interrupted by the delivery of a signal. To do this, we can add a signal to
the process’s signal mask — a set of signals whose delivery is currently blocked. They are stored 
then in the process's pending signal set inside the kernel. If a signal
is generated while it is blocked, it remains pending until it is later unblocked
(removed from the signal mask).

Upon delivery of a signal, a process carries out one of the following default
actions, depending on the signal:
- The signal is ignored; that is, it is discarded by the kernel and has no effect on
the process. (The process never even knows that it occurred.)
- The process is terminated (killed). This is sometimes referred to as abnormal
process termination, as opposed to the normal process termination that occurs
when a process terminates using exit().
- A core dump file is generated, and the process is terminated. A core dump file
contains an image of the virtual memory of the process, which can be loaded
into a debugger in order to inspect the state of the process at the time that it
terminated. 
- The process is stopped—execution of the process is suspended.
- Execution of the process is resumed after previously being stopped.

## DISPOSITION OF A SIGNAL:

Disposition of a signal is an establishing of the action which should occure when the signal is delivered.
A program can set one of the following dispositions for a signal:

- The default action should occur. This is useful to undo an earlier change of the
disposition of the signal to something other than its default.
- The signal is ignored. This is useful for a signal whose default action would be to
terminate the process.
- A signal handler is executed.

A signal handler is a function, written by the programmer, that performs appropri-
ate tasks in response to the delivery of a signal. For example, the shell has a handler
for the SIGINT signal (generated by the interrupt character, Control-C) that causes it to
stop what it is currently doing and return control to the main input loop, so that
the user is once more presented with the shell prompt.

Note that it isn’t possible to set the disposition of a signal to terminate or dump
core (unless one of these is the default disposition of the signal). This means that you cannot manually 
force a signal to have a termination or core-dumping behavior using sigaction() or signal().
The nearest we can get to this is to install a handler for the signal that then calls either exit() or abort().
The abort() function (Section 21.2.2) generates a SIGABRT signal for the process,
which causes it to dump core and terminate.

## Changing Signal Dispositions: signal() vs sigaction()

UNIX systems provide two ways of changing the disposition of a signal: signal() and
sigaction(). The signal() system call, which is described in this section, was the origi-
nal API for setting the disposition of a signal, and it provides a simpler interface
than sigaction(). On the other hand, sigaction() provides functionality that is not
available with signal(). Furthermore, there are variations in the behavior of signal()
across UNIX implementations (Section 22.7), which mean that it should never be
used for establishing signal handlers in portable programs. Because of these porta-
bility issues, sigaction() is the (strongly) preferred API for establishing a signal handler.

## Introduction to Signal Handlers

A signal handler (also called a signal catcher) is a function that is called when a speci-
fied signal is delivered to a process. Invocation of a signal handler may interrupt the main 
program flow at any time; the kernel calls the handler on the process’s behalf, and when the handler
returns, execution of the program resumes at the point where the handler inter-
rupted it.

When the kernel invokes a signal handler, it passes the number of the signal that
caused the invocation as an integer argument to the handler. (This is the sig argu-
ment in the handler). If a signal handler catches only one type of signal,
then this argument is of little use. We can, however, establish the same handler to
catch different types of signals and use this argument to determine which signal
caused the handler to be invoked.

! Real-world applications should generally never call stdio functions from within a signal handler.

## Sending Signals: kill()

One process can send a signal to another process using the kill() system call, which
is the analog of the kill shell command.
